import io.restassured.RestAssured;
import io.restassured.authentication.PreemptiveBasicAuthScheme;
import org.junit.jupiter.api.*;

import java.sql.*;
import java.util.ArrayList;
import java.util.Collection;

import static io.restassured.RestAssured.given;
import static io.restassured.RestAssured.when;
import static org.hamcrest.MatcherAssert.assertThat;
import static org.hamcrest.Matchers.*;

public class ApiTest {

    private static Connection connection;
    private final String COUNTRY_NAME = "WW";
    private final String ID_INCORRECT = "bad";
    private int createCountryId;
    private int notExistCountryId;
    private int uniqueCountryId;

    @BeforeAll
    public static void setUpAuth() {
        PreemptiveBasicAuthScheme authScheme = new PreemptiveBasicAuthScheme();
        authScheme.setUserName("admin");
        authScheme.setPassword("admin");
        RestAssured.authentication = authScheme;
    }

    @BeforeAll
    public static void setUpErrorLogging() {
        RestAssured.enableLoggingOfRequestAndResponseIfValidationFails();
    }

    @BeforeAll
    public static void connect() throws SQLException {
        connection = DriverManager.getConnection(
                "jdbc:postgresql://localhost/app-db",
                "app-db-admin",
                "P@ssw0rd"
        );
    }
//Для задания 14-5
//    @BeforeEach
//    public void insertCountryWhenIdIsAutogenerated() throws SQLException {
//        PreparedStatement sql = connection.prepareStatement(
//                "INSERT INTO country(country_name) VALUES(?)",
//                Statement.RETURN_GENERATED_KEYS
//        );
//        sql.setString(1, "ZZ");
//        sql.executeUpdate();
//        List<Integer> countryIds = new ArrayList<>();
//        ResultSet keys = sql.getGeneratedKeys();
//        while (keys.next()) {
//            countryIds.add(keys.getInt(1));
//        }
//        createCountryId = countryIds.get(0);
//    }

    @BeforeEach
    public void createTestCountry() throws SQLException {
        int bigId = -1;
        Statement sqlSelect = connection.createStatement();
        ResultSet resultSet = sqlSelect.executeQuery("SELECT * FROM country order by id desc limit 1");
        if (resultSet.next()) {
            bigId = resultSet.getInt(1);
        }
        createCountryId = bigId + 1;
        notExistCountryId = createCountryId + 999;

        PreparedStatement sqlInsert = connection.prepareStatement(
                "INSERT INTO country(id, country_name) VALUES(?,?)"
        );
        sqlInsert.setInt(1, createCountryId);
        sqlInsert.setString(2, COUNTRY_NAME);
        sqlInsert.executeUpdate();
    }

    @AfterEach
    public void deleteTestCountry() throws SQLException {
        PreparedStatement sqlDeleteCreatedCountry = connection.prepareStatement(
                "delete from country where id =?"
        );
        sqlDeleteCreatedCountry.setInt(1, createCountryId);
        sqlDeleteCreatedCountry.executeUpdate();

        PreparedStatement sqlDeleteUniqueCountry = connection.prepareStatement(
                "delete from country where id =?"
        );
        sqlDeleteUniqueCountry.setInt(1, uniqueCountryId);
        sqlDeleteUniqueCountry.executeUpdate();
    }

    @AfterAll
    public static void disconnect() throws SQLException {
        connection.close();
    }

    @Nested
    @DisplayName("Post methods")
    class PostMethodsTest {

        @Test
        public void createUniqueCountry() throws SQLException {
            uniqueCountryId = given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"countryName\": \"LA\"\n" +
                            "}")
                    .when()
                    .post("/api/countries")
                    .then()
                    .statusCode(201)
                    .body("id", not(empty()))
                    .extract()
                    .path("id");

            Collection<Integer> countryNames = new ArrayList<>();
            Statement sql = connection.createStatement();
            ResultSet resultSet = sql.executeQuery("SELECT * FROM country WHERE country_name = 'LA'");
            while (resultSet.next()) {
                countryNames.add(resultSet.getInt(1));
            }
            assertThat(countryNames.size(), is(1));
            assertThat(countryNames, hasItem(uniqueCountryId));

        }

        @Test
        public void creatingCountryNullName(){
            given()
                    .contentType("application/json")
                    .body("{\n" +
                            " \"countryName\":" + null +
                            "}")
                    .when()
                    .post("/api/countries")
                    .then()
                    .statusCode(400)
                    .body("title", is("Method argument not valid"),
                            "message", is("error.validation"),
                            "fieldErrors[0].objectName", is("country"),
                            "fieldErrors[0].field", is("countryName"),
                            "fieldErrors[0].message", is("must not be null"));
        }

        @Test
        public void createNotUniqueCountry() throws SQLException {
            PreparedStatement sqlUpdate = connection.prepareStatement(
                    "UPDATE public.country SET country_name = 'XX' WHERE id = ?"
            );
            sqlUpdate.setInt(1, createCountryId);
            sqlUpdate.executeUpdate();

            given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"countryName\": \"XX\"\n" +
                            "}")
                    .when()
                    .post("/api/countries")
                    .then()
                    .statusCode(500)
                    .body("title", is("Internal Server Error"));
        }

        @Test
        public void createCountryWithNameLessThanTwoCharactersLong() {
            given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"countryName\": \"m\"\n" +
                            "}")
                    .when()
                    .post("/api/countries")
                    .then()
                    .statusCode(400)
                    .body("title", is("Method argument not valid"),
                            "message", is("error.validation"),
                            "fieldErrors[0].objectName", is("country"),
                            "fieldErrors[0].field", is("countryName"),
                            "fieldErrors[0].message", is("size must be between 2 and 2"));
        }

        @Test
        public void creatingCountryWithNameLengthGreaterThenAcceptable() {
            given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"countryName\": \"ppp\"\n" +
                            "}")
                    .when()
                    .post("/api/countries")
                    .then()
                    .statusCode(400)
                    .body("title", is("Method argument not valid"),
                            "message", is("error.validation"),
                            "fieldErrors[0].objectName", is("country"),
                            "fieldErrors[0].field", is("countryName"),
                            "fieldErrors[0].message", is("size must be between 2 and 2"));
        }

//        @Test
//        @Disabled
//        public void creatingCountryWhenRequestBodyNotExist() {
//            given()
//                    .contentType("application/json")
//                    .when()
//                    .post("/api/countries")
//                    .then()
//                    .statusCode(400)
//                    .body("title", is("Bad Request"),
//                            "message", is("error.http.400"),
//                            "detail", containsString("Required request body is missing"));
//        }

    }

    @Nested
    @DisplayName("Get methods")
    class GetMethodsTest {

        @Test
        public void getCountryById() {
            when()
                    .get("/api/countries/" + createCountryId)
                    .then()
                    .statusCode(200)
                    .body("id", not(empty()),
                            "countryName", is(COUNTRY_NAME),
                            "locations", nullValue());
        }

        @Test
        public void getCountryByNotExistingId() {
            when()
                    .get("/api/countries/" + notExistCountryId)
                    .then()
                    .statusCode(404)
                    .body("title", is("Not Found"));
        }

        @Test
        public void getCountryByIdIncorrect() {
            when()
                    .get("/api/countries/" + ID_INCORRECT)
                    .then()
                    .statusCode(400)
                    .body("title", is("Bad Request"));
        }

    }

    @Nested
    @DisplayName("Patch methods")
    class PatchMethodsTest {

        @Test
        public void patchingCountry() throws SQLException {
            given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"id\": \"" + createCountryId + "\",\n" +
                            "  \"countryName\": \"LA\"\n" +
                            "}")
                    .when()
                    .patch("/api/countries/" + createCountryId)
                    .then()
                    .statusCode(200)
                    .body("id", is(createCountryId),
                            "countryName", is("LA"),
                            "locations", nullValue());

            Collection<Integer> countryIds = new ArrayList<>();

            Statement sql = connection.createStatement();
            ResultSet resultSet = sql.executeQuery("SELECT * FROM country WHERE country_name = 'LA'");
            while (resultSet.next()) {
                countryIds.add(resultSet.getInt(1));
            }
            assertThat(countryIds.size(), is(1));
            assertThat(countryIds, hasItem(createCountryId));


        }

        @Test
        public void patchingCountryWhenCountryIdNotExist() {
            given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"id\": \"" + notExistCountryId + "\",\n" +
                            "  \"countryName\": \"PA\"\n" +
                            "}")
                    .when()
                    .patch("/api/countries/" + notExistCountryId)
                    .then()
                    .statusCode(400)
                    .body("title", is("Entity not found"),
                            "entityName", is("country"),
                            "errorKey", is("idnotfound"));
        }

        @Test
        public void patchingCountryWithNotEqualsIdsInBodyAndUrl() {
            given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"id\": \"" + notExistCountryId + "\",\n" +
                            "  \"countryName\": \"PA\"\n" +
                            "}")
                    .when()
                    .patch("/api/countries/" + createCountryId)
                    .then()
                    .statusCode(400)
                    .body("title", is("Invalid ID"),
                            "entityName", is("country"),
                            "errorKey", is("idinvalid"));
        }

        @Test
        public void patchingCountryWhenIdIsIncorrect() {
            given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"id\": \"" + ID_INCORRECT + "\",\n" +
                            "  \"countryName\": \"PA\"\n" +
                            "}")
                    .when()
                    .patch("/api/countries/" + ID_INCORRECT)
                    .then()
                    .statusCode(400)
                    .body("title", is("Bad Request"));
        }

        @Test
        public void patchingCountryWhenIncorrectCountryName() {
            given()
                    .contentType("application/json")
                    .body("{\n" +
                            "  \"id\": \"" + createCountryId + "\",\n" +
                            "  \"countryName\": \"PAT\"\n" +
                            "}")
                    .when()
                    .patch("/api/countries/" + createCountryId)
                    .then()
                    .statusCode(500);
        }

    }

    @Nested
    @DisplayName("Delete methods")
    class DeleteMethodsTest {

        @Test
        public void deleteCountry() throws SQLException {
            when()
                    .delete("/api/countries/" + createCountryId)
                    .then()
                    .statusCode(204);

            Collection<Integer> countryIds = new ArrayList<>();

            Statement sql = connection.createStatement();
            ResultSet resultSet = sql.executeQuery("SELECT * FROM country WHERE id = '" + createCountryId + "'");
            while (resultSet.next()) {
                countryIds.add(resultSet.getInt(1));
            }
            assertThat(countryIds.size(), is(0));
        }

        @Test
        public void deleteCountryWhenIdNotExist() {
            when()
                    .delete("/api/countries/" + notExistCountryId)
                    .then()
                    .statusCode(500);
        }

        @Test
        public void deleteCountryWhenIncorrectId() {
            when()
                    .delete("/api/countries/" + ID_INCORRECT)
                    .then()
                    .statusCode(400)
                    .body("title", is("Bad Request"));
        }

    }

}